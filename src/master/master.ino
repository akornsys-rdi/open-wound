/* {{{ %%SECTION_HEADER%%
 * * * *
 * This header information is automatically generated by KodeUtils.
 *
 * File 'master.ino' edited by kwendenarmo, last modified: 2014-07-31.
 * This file is part of 'open wound' package, please see the readme files for more information about this file and this package.
 *
 * Copyright (C) 2014 Synusia by kwendenarmo <kwendenarmo@akornsys-rdi.net>
 * Released under the MIT License
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *
 * * * *
 * %%EOS_HEADER%% }}}
 */

#define PIR_ECHO_TIME 5000 //milisegundos de repetición de los PIR
#define SLAVES 12 //número de sensores, max 14
#define SLAVE_REFRESH_TIME 1000 //milisegundos de detección de pulsos
//comandos comunicación
#define CMD_PWR_OFF 0x50 //50
#define CMD_PWR_ON 0x51 //51
#define CMD_PIR 0x21 //21
const byte CMD_SLAVE_OFF[] = {0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A}; // (i*2)
const byte CMD_SLAVE_ON[] = {0x01, 0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1B}; // (i*2)+1

const byte sensorpin[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, A0, A1, A2}; //pines lectura de los sensores


void setup() {
    Serial.begin(9600); //comunicación con ordenador
    //establece las entradas para los sensores
    for (byte i = 0; i < 14; i++) {
        pinMode(sensorpin[i], INPUT);
    }
    pinMode(13, OUTPUT); //indicador de sensor activo
    pinMode(A3, OUTPUT); //salida conmutación fuente
    //entradas PIR
    pinMode(A4, INPUT);
    pinMode(A5, INPUT);
    digitalWrite(A3, HIGH); //fuente activa por defecto
}

void loop() {
    byte c = 0;
    boolean touch = false;
    static boolean pir = false;
    static boolean sense[SLAVES + 1];
    static boolean active[SLAVES + 1];
    static unsigned long timer = 0;
    static unsigned long timeout[SLAVES + 1];
  
    //escanea cada uno de los sensores
    for (byte i = 0; i < SLAVES; i++) {
        if (digitalRead(sensorpin[i])) {
            //si está activo pero no lo estaba anteriormente (t-1)
            if (!active[i]) {
                timeout[i] = millis();
                active[i] = true;
            }
            else {
            //si sigue activo
                if ((timeout[i] + SLAVE_REFRESH_TIME) > millis()) {
                    sense[i] = true;
                    Serial.write(CMD_SLAVE_ON[i]);
                }
            }
        }
        else {
            //si no está activo pero lo estaba anteriormente (t-1) manda señal de apagado de ese sensor
            if (sense[i]) {
                Serial.write(CMD_SLAVE_OFF[i]);
                sense[i] = false;
            }
            active[i] = false;
        }
    }
    //comprueba si alguno de los sensores está activo
    touch = false;
    for (byte i = 0; i < SLAVES; i++) {
        if (sense[i] == true) touch = true;
    }
    if (touch) digitalWrite(13, HIGH);
    else digitalWrite(13, LOW);
    //lee encendido/apagado del sistema
    if (Serial.available()) {
        c = Serial.read();
        if (c == CMD_PWR_OFF) digitalWrite(A3, LOW);
        else if (c == CMD_PWR_ON) digitalWrite(A3, HIGH);
    }
    //lee las entradas de los PIR
    if ((digitalRead(A4)) || (digitalRead(A5))) {
        if ((timer + PIR_ECHO_TIME) < millis()) {
            timer = millis();
            Serial.write(CMD_PIR);
        }
    }
    else {
        pir = false;
    }
}

