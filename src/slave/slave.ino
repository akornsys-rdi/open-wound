/* {{{ %%SECTION_HEADER%%
 * * * *
 * This header information is automatically generated by KodeUtils.
 *
 * File 'slave.ino' edited by kwendenarmo, last modified: 2014-07-30.
 * This file is part of 'open wound' package, please see the readme files for more information about this file and this package.
 *
 * Copyright (C) 2014 Synusia by kwendenarmo <kwendenarmo@akornsys-rdi-net>
 * Released under the MIT License
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *
 * * * *
 * %%EOS_HEADER%% }}}
 */

#define CALTIMER 10000 //milisegundos de calibración inicial
#define THRESHOLD 1 //número de veces que se ha de superar el umbral para detectar

//libreria CMTU
#include <CapacitiveSensor.h>
CapacitiveSensor blade = CapacitiveSensor(4,3); //emisor, receptor

void setup() {
    blade.set_CS_AutocaL_Millis(0xFFFF); //inicializa el CMTU
    Serial.begin(9600); //UART para debug
    pinMode(2, OUTPUT); // salida de detección
    //pines como salida a nivel bajo, no conectados
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
    pinMode(7, OUTPUT);
    pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);
    pinMode(11, OUTPUT);
    pinMode(12, OUTPUT);
    pinMode(13, OUTPUT);
    pinMode(A0, OUTPUT);
    pinMode(A1, OUTPUT);
    pinMode(A2, OUTPUT);
    pinMode(A3, OUTPUT);
    pinMode(A4, OUTPUT);
    pinMode(A5, OUTPUT);
}

void loop() {
   static boolean cal = true;
   static unsigned long timer = 0;
   static unsigned long maxval = 0;
   static unsigned long minval = 0xFFFFFFFF;
   static unsigned long rangeval = 0;
   static unsigned long readval = 0;
   
   //calibración inicial
   timer = millis();
   readval = blade.capacitiveSensor(30);
   if (timer < CALTIMER) {
     cal = true;
     if (readval > maxval) maxval = readval;
     if (readval < minval) minval = readval;
   }
   else {
     //imprime los valores de calibración
     if (cal) {
       cal = false;
       rangeval = maxval - minval;
       Serial.print("max: ");
       Serial.println(maxval, DEC);
       Serial.print("min: ");
       Serial.println(minval, DEC);
       Serial.print("range: ");
       Serial.println(rangeval, DEC);
     }
     else {
       //bucle sin fin de lectura-comparación-salida
       do {
         readval = blade.capacitiveSensor(30);
         if (((readval - maxval) > (rangeval * THRESHOLD)) && (readval > maxval)) digitalWrite(2, HIGH);
         else digitalWrite(2, LOW);
         delay(50);
         Serial.println(readval);
       } while(1);
     }
  } 
}

